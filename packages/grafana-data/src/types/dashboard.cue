package grafanaschema

// TODO it is really less than ideal that we have to define all the potentially
// separable sub-objects (dashboard vs panel vs target vs fieldconfig) in the
// same place, but i haven't yet figured out a way to maintain the most
// important invariant - preserving and extending old versions as schema evolve
// - without keeping them all declared in the same sequence Family and sequence.
// It does seems plausible that there's a reasonable way.


dashboardFamily: #SchemaFamily & {
	seqs: [
		[ // 0.0
			{
                // Base dashboard schema.
                Dashboard: {
                    // Unique numeric identifier for the dashboard.
                    // TODO must isolate or remove identifiers local to a Grafana instance...?
                    id: int
                    // Unique dashboard identifier that can be generated by anyone. string (8-40)
                    uid: string
                    // Title of dashboard.
                    title?: string
                    // Description of dashboard.
                    description?: string
                    // Tags associated with dashboard.
                    tags?: [...string]
                    // Theme of dashboard.
                    style: *"light" | "dark"
                    // Timezone of dashboard,
                    timezone?: *"browser" | "utc"
                    // Whether a dashboard is editable or not.
                    editable: bool | *true
                    // 0 for no shared crosshair or tooltip (default).
                    // 1 for shared crosshair.
                    // 2 for shared crosshair AND shared tooltip.
                    graphTooltip: int >= 0 <= 2 | *0
                    // Time range for dashboard, e.g. last 6 hours, last 7 days, etc
                    time?: {
                        from: string | *"now-6h"
                        to:   string | *"now"
                    }
                    // Timepicker metadata.
                    timepicker?: {
                        // Whether timepicker is collapsed or not.
                        collapse: bool | *false
                        // Whether timepicker is enabled or not.
                        enable: bool | *true
                        // Whether timepicker is visible or not.
                        hidden: bool | *false
                        // Selectable intervals for auto-refresh.
                        refresh_intervals: [...string] | *["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
                    }
                    // Templating.
                    templating?: list: [...{...}]
                    // Annotations.
                    annotations?: list: [...{
                        builtIn: int | *0
                        // Datasource to use for annotation.
                        datasource: string
                        // Whether annotation is enabled.
                        enable?: bool | *true
                        // Whether to hide annotation.
                        hide?: bool | *false
                        // Annotation icon color.
                        iconColor?: string
                        // Name of annotation.
                        name?: string
                        // Query for annotation data.
                        rawQuery: string
                        showIn:   int | *0
                    }] | *[]
                    // Auto-refresh interval.
                    refresh: string
                    // Version of the JSON schema, incremented each time a Grafana update brings
                    // changes to said schema.
                    schemaVersion: int | *25
                    // Version of the dashboard, incremented each time the dashboard is updated.
                    version: string
                    panels?: [...Panel]
                }
                // Dashboard panels. Panels are canonically defined inline
                // because they share a version timeline with the dashboard
                // schema; they do not vary independently. We create a separate,
                // synthetic Family to represent them in Go.
                Panel: {
                    // The panel plugin type id. 
                    type: !=""

                    // Panel title.
                    title?: string
                    // Description.
                    description?: string
                    // Whether to display the panel without a background.
                    transparent: bool | *false
                    // Name of default datasource.
                    datasource?: string
                    // Grid position.
                    gridPos?: PanelGridPos
                    // Panel links.
                    // links?: [..._panelLink]
                    // Name of template variable to repeat for.
                    repeat?: string
                    // Direction to repeat in if 'repeat' is set.
                    // "h" for horizontal, "v" for vertical.
                    repeatDirection: *"h" | "v"
                    // TODO Schema for panel targets is specified by datasource
                    // plugins. We use a placeholder definition, which the Go
                    // schema loader either left open/as-is with the Base
                    // variant of the Dashboard and Panel families, or filled
                    // with types derived from plugins in the Instance variant.
                    // When working directly from CUE, importers can extend this
                    // type directly to achieve the same effect.
                    targets?: [...{}]

                    // The values depend on panel type
                        options: {}

                    // TODO This references a type defined outside the Family
                    // decl. This probably isn't OK at all, because it means we
                    // won't have snapshots of the historical versions of
                    // FieldConfig, which makes it impossible to guarantee
                    // immutability of historical schema.
                    //
                    // But it miiiiiight be something we could slide by with if
                    // we maintain the invariant that the referenced type may
                    // never change in a backwards-incompatible way. (That's
                    // gonna be absolutely necessary in any referencing
                    // scenario.)
                    fieldConfig: FieldConfigSource
                }
            }
		]
	]
}

#Latest: {
    #Dashboard: dashboardFamily.latest.Dashboard
    #Panel: dashboardFamily.latest.Panel
}